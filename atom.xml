<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CoolBreeze的博客</title>
  
  <subtitle>胆小认生,不易相处</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bzkco70.cn/"/>
  <updated>2020-12-16T07:14:29.851Z</updated>
  <id>http://bzkco70.cn/</id>
  
  <author>
    <name>CoolBreeze</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cross-origin(跨域)详解</title>
    <link href="http://bzkco70.cn/2020/12/16/cross-origin/"/>
    <id>http://bzkco70.cn/2020/12/16/cross-origin/</id>
    <published>2020-12-15T16:00:00.000Z</published>
    <updated>2020-12-16T07:14:29.851Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/blogImg/bys0.jpg" alt="这是一个老头"></p><h2 id="1-什么是跨域"><a href="#1-什么是跨域" class="headerlink" title="1.什么是跨域"></a>1.什么是跨域</h2><p>就是非同源请求，同源即端口号、主机和协议相同。<br><a id="more"></a></p><h2 id="2-为什么会出现："><a href="#2-为什么会出现：" class="headerlink" title="2.为什么会出现："></a>2.为什么会出现：</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">由于浏览器的同源策略限制，</span><br><span class="line"><span class="bullet">1. </span>通常浏览器允许进行跨域的写操作，如链接、重定向</span><br><span class="line"><span class="bullet">2. </span>通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签</span><br><span class="line"><span class="bullet">3. </span>通常浏览器不允许跨域读操作（Cross-origin reads）</span><br></pre></td></tr></table></figure><h2 id="3-jsonP解决跨域"><a href="#3-jsonP解决跨域" class="headerlink" title="3.jsonP解决跨域"></a>3.jsonP解决跨域</h2><h4 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/localhost:3000/</span>?callback=getData<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`收到客户端请求了: <span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">var</span> _callback=req.query.callback;<span class="comment">//接收到的是一个函数</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      status_code: <span class="number">200</span>,</span><br><span class="line">      result: &#123;</span><br><span class="line">        name: <span class="string">'张三'</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        friends: [<span class="string">'李四'</span>, <span class="string">'王五'</span>, <span class="string">'赵六'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(_callback+<span class="string">"("</span>+data+<span class="string">")"</span>);<span class="comment">//相当于响应的是getData(data)的执行结果。</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理：由于同源策略限制，虽然不能通过XMLhttprequest,但能引入js文件，随后触发回调，服务器将数据返回给客户端。</span><br><span class="line">优点：兼容性好，可以解决不同浏览器的跨域问题。</span><br><span class="line">缺点：只支持<span class="keyword">get</span>请求，不安全，</span><br></pre></td></tr></table></figure><h2 id="4-req-query-req-params-req-body的区别："><a href="#4-req-query-req-params-req-body的区别：" class="headerlink" title="4.req.query\req.params\req.body的区别："></a>4.req.query\req.params\req.body的区别：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>req.params:</span><br><span class="line">  所对应的url长这个样子 http:<span class="comment">//localhost:3000/10</span></span><br><span class="line">  app.get(<span class="string">"/:id"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req.res</span>)</span>&#123;</span><br><span class="line">    res.send(req.params[<span class="string">"id"</span>]);</span><br><span class="line">  &#125;)</span><br><span class="line">  通过这样才能拿到id的值，即<span class="number">10</span>；</span><br><span class="line"><span class="number">2.</span>req.query:</span><br><span class="line">  所对应的url长这个样子http:<span class="comment">//localhost:3000/?id=10</span></span><br><span class="line">  app.get(<span class="string">"/"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">      res.send(req.query[<span class="string">"id"</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="number">3.</span>req.body:</span><br><span class="line">  这个用在post请求中。通常用法：</span><br><span class="line">  app.post(<span class="string">"/login"</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    req.body.pwd;</span><br><span class="line">    req.body.name;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="5-CORS：跨域资源共享"><a href="#5-CORS：跨域资源共享" class="headerlink" title="5.CORS：跨域资源共享"></a>5.CORS：跨域资源共享</h2><p>  主要分为简单请求和非简单请求，平时差不多用到的就是get post，所以简单请求就够了，浏览器会自动在请求头中添加 origin 字段，我们不需要操作：origin ：<a href="http://localhost:3000。在服务器端：配置Access-Control-Allow-Origin属性。指定允许的请求源域名，可以通过指定为" target="_blank" rel="noopener">http://localhost:3000。在服务器端：配置Access-Control-Allow-Origin属性。指定允许的请求源域名，可以通过指定为</a> *来指定所有域名。配置该属性的方式为：在app.js中添加如下代码：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//  res.header("Access-Control-Allow-Origin", "http://localhost:3000");</span></span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);<span class="comment">//*就是所有域名都能跨域</span></span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="string">'/'</span>, index);</span><br></pre></td></tr></table></figure></p><h2 id="6-postMessage"><a href="#6-postMessage" class="headerlink" title="6.postMessage"></a>6.postMessage</h2><p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。<br>postMessage(data,origin)方法接受两个参数：<br>// 注意这里不是要获取iframe的dom引用，而是iframe window的引用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://10.73.154.73:8088'</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'data from domain2 sss ---&gt; '</span> + e.data);</span><br><span class="line">  &#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><h2 id="7-vue常用的跨域方法："><a href="#7-vue常用的跨域方法：" class="headerlink" title="7.vue常用的跨域方法："></a>7.vue常用的跨域方法：</h2><p>在根目录下创建vue.config.js文件,内容参考如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">'/'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://demo.itlike.com/web/xlmc'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//上面的pathRewrite就是遇到第二哥/api的时候替换为空，</span></span><br><span class="line">      <span class="string">'/pay'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://47.98.157.152/WXPayProject/pay'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/pay'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="8-react常用跨域方法："><a href="#8-react常用跨域方法：" class="headerlink" title="8.react常用跨域方法："></a>8.react常用跨域方法：</h2><p>在src目录下创建setupProxy.js,内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(</span><br><span class="line">    <span class="string">'/api'</span>,</span><br><span class="line">    createProxyMiddleware(&#123;</span><br><span class="line">      target: <span class="string">'http://localhost:3001'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../assets/blogImg/bys0.jpg&quot; alt=&quot;这是一个老头&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-什么是跨域&quot;&gt;&lt;a href=&quot;#1-什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;1.什么是跨域&quot;&gt;&lt;/a&gt;1.什么是跨域&lt;/h2&gt;&lt;p&gt;就是非同源请求，同源即端口号、主机和协议相同。&lt;br&gt;
    
    </summary>
    
    
      <category term="跨域" scheme="http://bzkco70.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>git详解</title>
    <link href="http://bzkco70.cn/2020/12/11/git/"/>
    <id>http://bzkco70.cn/2020/12/11/git/</id>
    <published>2020-12-10T16:00:00.000Z</published>
    <updated>2020-12-14T08:13:58.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git的功能"><a href="#git的功能" class="headerlink" title="git的功能"></a>git的功能</h2><p>代码回滚、代码合并、版本备份、权限控制、追究责任等。<br>他能追踪一个项目从诞生到定案的过程、记录项目所有变化，无限制返回、查看特定版本的修情况。<br><a id="more"></a></p><h2 id="git和svn比较"><a href="#git和svn比较" class="headerlink" title="git和svn比较"></a>git和svn比较</h2><p>git为分布式版本控制（在每个客户端都有一份完整的代码仓库, 可以在每个客户端自行管理）<br>svn为集中式版本控制（所有的代码都集中在一块, 统一进行管理）</p><h2 id="git的工作流程"><a href="#git的工作流程" class="headerlink" title="git的工作流程"></a>git的工作流程</h2><p>git add .(.或者其他文件) -&gt; git commit -m “” -&gt; git pull -&gt;git push  </p><h2 id="git的使用经验"><a href="#git的使用经验" class="headerlink" title="git的使用经验"></a>git的使用经验</h2><p>每天走之前, 提交一份没有问题的代码到服务器，每天早上来之前, 从服务器拉一份最新的代码到本地再进行开发  </p><h2 id="git的使用方式"><a href="#git的使用方式" class="headerlink" title="git的使用方式"></a>git的使用方式</h2><p>命令行、ws这些前端工具。</p><h2 id="常见的unix命令"><a href="#常见的unix命令" class="headerlink" title="常见的unix命令"></a>常见的unix命令</h2><ol><li>必学命令<br> help [子命令] : 查看某一个具体的子命令的使用方法  </li><li>常用命令  <ul><li>cd path : 将当前路径切换到path路径<ul><li>pwd ：查看当前所在路径</li><li>ls (-a / -l / -G) :  查看当前文件夹下所有文件及文件夹</li><li>touch filename1 filename2 ： 创建一个或者多个文件 </li><li>rm filename : 删除文件</li><li>cat filename ：查看文件内容</li><li>less filename ：分页查看文件内容</li><li>mkdir 文件夹名称 ：创建一个文件夹</li><li>rmdir 文件夹名称 ：删除一个文件夹</li><li>mv oldFilePath newFilePath ：移动文件(可借助此命令给文件重命名)  </li></ul></li></ul></li><li>vi编辑器<br>三种模式：命令行模式、末行模式、输入模式，输入vi就进入命令行模式，输入a或i就到插入模式，接着esc到命令行模式，接着shift+:到末行模式，wq保存并退出，！q强制退出。末行模式esc到命令行模式。  </li></ol><h2 id="git工作原理："><a href="#git工作原理：" class="headerlink" title="git工作原理："></a>git工作原理：</h2><p>git有工作区和版本控制库这两个东西，工作区就是文件目录下（除了.git）的就是工作区，版本库就是目录下.git目录，当添加/修改/删除后，git add后先是将添加的文件推送到版本库的暂缓区，git commit 后将添加的文件推送到版本库的分支上，默认是master分支，通过HEAD指针来切换分支。  </p><h2 id="git本地仓库的搭建："><a href="#git本地仓库的搭建：" class="headerlink" title="git本地仓库的搭建："></a>git本地仓库的搭建：</h2><p>初始化git init-&gt;配置仓库（告诉git你是谁，怎么联系。。。git config user.name “你的名字”  git…email “”,配置好了查看这些配置的信息，git config -l）。</p><h2 id="git-基本使用："><a href="#git-基本使用：" class="headerlink" title="git 基本使用："></a>git 基本使用：</h2><p>创建文件并提交：touch 文件 git add  git commit-》修改文件并提交-》删除文件并提交：git rm 文件 。。。<br>git 日志查看的方式：1）git log  2)git relog  版本号唯一<br>git 查看文件状态：git status  红色表示文件添加或修改或删除的文件没有被添加到暂缓区，绿色表示文件在暂缓去等待提交。</p><h2 id="git版本回退："><a href="#git版本回退：" class="headerlink" title="git版本回退："></a>git版本回退：</h2><p>如果尚未提交：回退到当前版本：git reset –hard HEAD<br>如果提交了：<br>git reset –hard HEAD^ 重置到上个版本<br>git reset –hard HEAD~2 重置到往上2个版本<br>git reset –hard  HEAD@{版本号}七位版本号 重置到指定版本<br>然后再使用git push –force将本次变更强行推送至服务器。这样在服务器上的对应版本的错误提交也彻底消失了。</p><h2 id="共享库分类："><a href="#共享库分类：" class="headerlink" title="共享库分类："></a>共享库分类：</h2><p>远程共享库和本地共享库，远程的就比如GitHub，本地共享库的例子好比如在一个电脑上，有一个共享库，另外有两个文件目录分别在本地共享库拉取提交代码。git clone “c:/user….(本地共享库地址)”，搭建本地共享库mkdir share/cd share/git init –bare。</p><h2 id="解决冲突："><a href="#解决冲突：" class="headerlink" title="解决冲突："></a>解决冲突：</h2><p>这个通常我们在使用前最好拉一下代码，否则如果本地文件的版本低于共享库的文件版本, 提交时就会报超时错误，冲突解决：如果俩人在用一个共享库的一个文件，另一个修改提交并且推送，另一个也修改提交推送时就会提升merge，这时就要合并一下代码接着点击merge，这时通常把别人的放在前面，自己的放在后面，接着apply一下，如果没有成功重新推送一下。</p><h2 id="配置忽略文件："><a href="#配置忽略文件：" class="headerlink" title="配置忽略文件："></a>配置忽略文件：</h2><p>有些文件对自己有用，对别人没有，就不必上传到服务器了。<br>  就是在当前目录下，touch .gitignore  接着打开这个文件在里面写上要忽略的文件名即可。只能忽略工作区文件，如果已经在暂缓区，则无法忽略。</p><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><p>  首先如果远程有多个分支，如果是master分支，直接拉，如果是有其他分支，拉取代码命令为：git clone -b dev ssh地址<br>查看当前分支  git branch -a  -&gt;查看本地分支git branch -&gt;创建分支 git branch 分支名称 -&gt;将创建的分支推送都远程git push origin 分支名称 -&gt;切换分支 git checkout 分支名称 -&gt;删除分支 git branch -d 分支名称 -&gt;删除远程分支 git push origin :分支名称。<br>这里如果想将其他分支合并到master分支，首先提交当前分支的代码，接着切换到master分支，master分支如果是多人开发就要pull一下，接着就是合并 git merge dev(假设要合并dev分支的) 接着就git status 查看合并代码是否有冲突，最后git push origin master,如果想切回原来的分支继续开发就git checkout dev </p><h2 id="git打包"><a href="#git打包" class="headerlink" title="git打包"></a>git打包</h2><p>  给项目打一个标签，就是打一个版本，git tag -a v1.0 -m “tag”,接着上传 git push origin v1.0</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git的功能&quot;&gt;&lt;a href=&quot;#git的功能&quot; class=&quot;headerlink&quot; title=&quot;git的功能&quot;&gt;&lt;/a&gt;git的功能&lt;/h2&gt;&lt;p&gt;代码回滚、代码合并、版本备份、权限控制、追究责任等。&lt;br&gt;他能追踪一个项目从诞生到定案的过程、记录项目所有变化，无限制返回、查看特定版本的修情况。&lt;br&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://bzkco70.cn/tags/git/"/>
    
  </entry>
  
</feed>
