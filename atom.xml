<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CoolBreeze的博客</title>
  
  <subtitle>匡扶正义，保护百姓</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bzkco70.cn/"/>
  <updated>2020-12-21T11:49:12.698Z</updated>
  <id>http://bzkco70.cn/</id>
  
  <author>
    <name>CoolBreeze</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack详解</title>
    <link href="http://bzkco70.cn/2020/12/21/webpack/"/>
    <id>http://bzkco70.cn/2020/12/21/webpack/</id>
    <published>2020-12-20T16:00:00.000Z</published>
    <updated>2020-12-21T11:49:12.698Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用webpack"><a href="#为什么要使用webpack" class="headerlink" title="为什么要使用webpack"></a>为什么要使用webpack</h4><p>因为在前端开发中，为了遵循模块化开发，会产生很多互相依赖的单独文件，在加载的时候会发送很多请求，导致加载速度慢，再比如一些像less或者es6的一些东西浏览器根本识别不了，这时就需要手动转为css,但是太麻烦了。为了解决诸多的问题就使用webpack,将这个js模块，css模块，img模块统统构建出压缩合并的产品。</p><a id="more"></a><h4 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h4><p>说白了，它就是一个静态的打包工具，它把css,js,less等都当模块来处理，根据模块的依赖关系进行静态分析，打包成对应的静态资源(bundle)。他的过程大概就是 找到入口文件 —&gt;  各种引入 —&gt; 根据各种依赖建立chunk块 —&gt; 把less转成css ES6/7/8/9 转成ES5 —&gt; 各种bundle包 –&gt; 引入各种bundle包  执行。</p><p>webpack默认打包的时候只会处理js和json，就像img，css等这些它都是处理不了的，需要使用loader，webpack有两种环境，开发环境(代码本地调试和运行的环境)和生产环境（代码优化上线运行的环境）。当只有js和json的时候打包的命令是这样的：webpack ./src/index.js  -o  ./build/dist.js –mode=development,这是在开发模式下，在生产模式下只需要将development换成production。（补充：在这个安装webpack的时候，也安装一下webpack-cli(npm i webpack webpack-cli –save-dev),–save-dev可以换成-D）</p><h4 id="webpack的核心"><a href="#webpack的核心" class="headerlink" title="webpack的核心"></a>webpack的核心</h4><ul><li><p>entry：入口<br>通常的写法是entry：’./src/index.js’（当前是字符串，还可以是array(entry:[“”,””])、object（entry：{“”,””}））<br>//多入口，多出口，有几个入口就会生成几个chunk,几个bundle<br>混合使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry：&#123;</span><br><span class="line">a: <span class="string">'./src/js/index.js'</span>,</span><br><span class="line">  index：[</span><br><span class="line">    <span class="string">'./src/js/index.js'</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(vue:[‘vue’,’vuex’]这样的场景能用得到）</p></li><li><p>output:出口<br>  通常写法是output: {filename: ‘js/dist.js’,path: resolve(__dirname, ‘build’)},但如果想让配置公共路径，就让生产的bundle在一个文件夹下，就要配置公共路径output: {filename: ‘js/dist.js’,path: resolve(__dirname, ‘build’)， publicPath:’/itlike’，library:’itlike } //配置打包后，如果库要对外暴露变量名就加最后一行代码 ，之后会在dist文件最上面多出var itlike={}</p></li><li><p>loader：webpack默认只能处理js/json，但除此之外都不能处理，这时就要用到loader去处理那些非js,非json的东西。<br>通常的写法：(这是打包样式资源的例子)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="comment">// 规则</span></span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 匹配哪些文件</span></span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="comment">// 使用哪些loader来处理这些匹配到的css文件</span></span><br><span class="line">      use: [</span><br><span class="line">        <span class="comment">// use中loader的加载顺序： 从下到上，从右到左，依次执行</span></span><br><span class="line">        <span class="comment">// 创建style标签，将js中的样式资源添加到页面的头部标签中</span></span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        <span class="comment">// 将css文件转成commonJS模块， 加载到js中， 内容都是“样式字符串”</span></span><br><span class="line">        <span class="string">'css-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        <span class="string">'css-loader'</span>,</span><br><span class="line">        <span class="comment">// 把less的代码转成css的代码</span></span><br><span class="line">        <span class="comment">// less less-loader</span></span><br><span class="line">        <span class="string">'less-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>plugins:插件可以让webpack的功能更广泛，例如打包优化、压缩等。<br>写法：(这个例子是自动创建打包生成的html模板，在不用它的时候，每次需要手动的将src目录下的html文件复制到build下，用了它就不用手动复制了，会自动生成并引入，如果不想用自动生成的模板，还可以用template指明特定的html文件，不过需要安装引入html-webpack-plugin插件，const HtmlWebpackPlugin = require(‘html-webpack-plugin’);)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="comment">// html-webpack-plugin</span></span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: <span class="string">'./src/index.html'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>modules:在模块化编程中，开发者将程序分解成离散功能块，并称之为模块</p></li><li><p>mode:就是模式的选择<br>通常写法是 mode: ‘development’,//or production</p></li><li><p>devServer:服务器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line"><span class="comment">// 项目构建后的路径</span></span><br><span class="line">contentBase: resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">  <span class="comment">// 启动的端口号</span></span><br><span class="line">port: <span class="number">3000</span>,</span><br><span class="line"><span class="comment">// 自动打开浏览器</span></span><br><span class="line"><span class="comment">// open: true</span></span><br><span class="line"><span class="comment">// 启用gzip压缩</span></span><br><span class="line">compress: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="webpack配置文件"><a href="#webpack配置文件" class="headerlink" title="webpack配置文件"></a>webpack配置文件</h4><p>它指示webpack要做那些事情，通常在根目录下创建一个webpack.config.js的文件，为了遵循nodejs的commonjs规范，通常写法是module.exports={},{}里面就是entry，output这些。在用了配置文件后，就可以直接使用webpack命令去打包了。</p><h4 id="处理图片资源"><a href="#处理图片资源" class="headerlink" title="处理图片资源"></a>处理图片资源</h4><p>需要安装一下file-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">    <span class="comment">// url-loader 依赖于 file-loader</span></span><br><span class="line">    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">// 图片的大小 &lt; 60kb, 就进行base64的处理</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        优点：减少请求的数量， 减轻服务器端的开销</span></span><br><span class="line"><span class="comment">        缺点： 文件请求速度变慢</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      limit: <span class="number">60</span> * <span class="number">1024</span>,</span><br><span class="line">      <span class="comment">// 给图片重命名</span></span><br><span class="line">      name: <span class="string">'[hash:24].[ext]'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果在模板文件即HTML文件中引入了照片，做如下处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.html$/</span>,</span><br><span class="line">  loader: <span class="string">'html-loader'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在打包之前，删除整个目标文件夹中的内容"><a href="#在打包之前，删除整个目标文件夹中的内容" class="headerlink" title="在打包之前，删除整个目标文件夹中的内容"></a>在打包之前，删除整个目标文件夹中的内容</h4><p>这时就要在plugins中使用一个插件：clean-webpack-plugin(const { CleanWebpackPlugin } = require(‘clean-webpack-plugin’);)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin ()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="打包字体图标"><a href="#打包字体图标" class="headerlink" title="打包字体图标"></a>打包字体图标</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file-loader 打包其它文件资源</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 排除css/js/html</span></span><br><span class="line">  exclude: <span class="regexp">/\.(css|js|html|json)$/</span>,</span><br><span class="line">  <span class="comment">// npm i file-loader -D</span></span><br><span class="line">  loader: <span class="string">'file-loader'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是把css,js,html,json除外（就是用这种方式来处理）</p><h4 id="开发服务器"><a href="#开发服务器" class="headerlink" title="开发服务器"></a>开发服务器</h4><p>npm i webpack-dev-server -D<br>webpack-dev-server: 开发服务器</p><ul><li>自动化 (自动编译、自动打开浏览器、自动刷新浏览器、……)</li><li>特点： 只会在内存中打包、不会任何的真实输出（就是不会生成bundle包，只在内存中打包）</li><li>启动服务器 npx webpack-dev-server<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 项目构建后的路径</span></span><br><span class="line">  contentBase: resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">  <span class="comment">// 启动的端口号</span></span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  <span class="comment">// 自动打开浏览器</span></span><br><span class="line">  <span class="comment">// open: true</span></span><br><span class="line">  <span class="comment">// 启用gzip压缩</span></span><br><span class="line">  compress: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li><p>就像在img,js打包之后都会在在dist文件中，如果想要img，js等打包后生成对应的文件，就要设置输出的文件夹即在options中设置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">  name: <span class="string">'[hash:12].[ext]'</span>,</span><br><span class="line">  <span class="comment">// 设置输出的文件夹</span></span><br><span class="line">  outputPath: <span class="string">'img'</span><span class="comment">//or 'js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用多个loader用use，使用一个loader，用loader  eg:loader:”url-loader”/use:[“”，””]</p></li></ul><h4 id="提取css文件"><a href="#提取css文件" class="headerlink" title="提取css文件"></a>提取css文件</h4><p>把构建的dist文件中把css提取出来,需要使用一个插件 mini-css-extract-plugin(const MiniCssExtractPlugin = require(‘mini-css-extract-plugin’);)使用它后就不能使用style-loader这个loader，将style-loader替换为MiniCssExtractPlugin.loader,接着在plugins中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  <span class="keyword">new</span> MiniCssExtractPlugin (&#123;</span><br><span class="line">  filename: <span class="string">'css/index.css'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="处理css兼容性问题"><a href="#处理css兼容性问题" class="headerlink" title="处理css兼容性问题"></a>处理css兼容性问题</h4><p>就是在用的时候可能会使用css3/css4的一些东西，打包打成低版本的，就会存在兼容性问题，在生成的包中可能会多出一些兼容性代码。使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use: [</span><br><span class="line">  <span class="comment">/*'style-loader',*/</span></span><br><span class="line">  MiniCssExtractPlugin.loader,</span><br><span class="line">  <span class="string">'css-loader'</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//配置postcss-loader，处理css兼容性问题</span></span><br><span class="line">    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      ident: <span class="string">'postcss'</span>,</span><br><span class="line">      plugins: <span class="function">(<span class="params">loader</span>) =&gt;</span> [</span><br><span class="line">        <span class="comment">//postcss-preset-env会将最新的CSS语法转换为目标环境的浏览器能够理解的CSS语法</span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'postcss-preset-env'</span>)()</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>除此之外，在package.json中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"browserslist"</span>: &#123;</span><br><span class="line">  <span class="string">"development"</span>: [</span><br><span class="line">    <span class="string">"last 1 chrome version"</span>,</span><br><span class="line">    <span class="string">"last 1 firefox version"</span>,</span><br><span class="line">    <span class="string">"last 1 safari version"</span></span><br><span class="line">  ],</span><br><span class="line">    <span class="string">"production"</span>: [</span><br><span class="line">      <span class="string">"&gt; 0.2%"</span>,</span><br><span class="line">      <span class="string">"not dead"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>另外process.env.NODE_ENV 可以切换当前模式，例如process.env.NODE_ENV = “development”;配置在module.exports={}外面。</p><h4 id="压缩css"><a href="#压缩css" class="headerlink" title="压缩css"></a>压缩css</h4><p>使用插件：optimize-css-assets-webpack-plugin（const OptimizeCssAssetsPlugin = require(‘optimize-css-assets-webpack-plugin’);）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  <span class="keyword">new</span> OptimizeCssAssetsPlugin （）；</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="eslint语法检查"><a href="#eslint语法检查" class="headerlink" title="eslint语法检查"></a>eslint语法检查</h4><p>可能自己写的一些代码不规范，不使用eslint没事，因为不会给你检查，如果使用了eslint 它就会给你检查，不规范的话在打包的时候可能会报错。使用如下：<br>npm i eslint  eslint-loader eslint-plugin-import  eslint-config-airbnb-base -D（最后用的是airbnb的标准来检查这个语法，使用eslint-config-airbnb-base需要在package.json中配置一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"eslintConfig"</span>: &#123;</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">"airbnb-base"</span></span><br><span class="line">  &#125;</span><br><span class="line">）</span><br><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">    <span class="comment">//  自动修复eslint语法错误</span></span><br><span class="line">    options: &#123;</span><br><span class="line">      fix: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>如果不想让eslint检查该行代码，只需在该行前面加上一行注释：// eslint-disable-next-line</p><h4 id="js语法兼容性处理"><a href="#js语法兼容性处理" class="headerlink" title="js语法兼容性处理"></a>js语法兼容性处理</h4><p>存在问题：<br>一些ES6 / 7 / 8的语法， 浏览器不能够完全识别，需要做兼容性（就像es6语法在chrome上可以运行<br>，但在IE低版本浏览器报错，这时就用到babel，把高阶语法转成低阶的，但只能转一些普通的js语法，像promise这样的<br>就转不了，这时就用到了下面的“2）”，在js中引入@babel/polyfill）</p><ol><li><p>babel - loader  依赖于 @babel/core  @babel/preset - env<br>npm i babel - loader @babel/core @babel/preset - env - D</p></li><li><p>引入全局的js兼容性处理– &gt; @babel/polyfill<br>npm i @babel/polyfill -D</p></li></ol><ul><li><p>如果是普通js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">// 预设</span></span><br><span class="line">      presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果js中有像promise这样的 npm i @babel/polyfill -D, 在js文件最前面加上 import ‘@babel/polyfill’,一般就是二者结合使用。</p></li></ul><h4 id="Babel和eslint冲突"><a href="#Babel和eslint冲突" class="headerlink" title="Babel和eslint冲突"></a>Babel和eslint冲突</h4><p>如果有语法错误，就没必要做那个js兼容性处理，所以只要让eslint优先执行。如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">  <span class="comment">// 加上这一句： 优先执行</span></span><br><span class="line">  enforce: <span class="string">'pre'</span>,</span><br><span class="line">  <span class="comment">//  自动修复eslint语法错误</span></span><br><span class="line">  options: &#123;</span><br><span class="line">      fix: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="压缩html和js"><a href="#压缩html和js" class="headerlink" title="压缩html和js"></a>压缩html和js</h4><p>压缩html就是让生成的html去掉空格、移除注释就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  template: <span class="string">'./src/index.html'</span>,</span><br><span class="line">  <span class="comment">// 压缩HTML的代码</span></span><br><span class="line">  minify: &#123;</span><br><span class="line">      <span class="comment">// 移除空格</span></span><br><span class="line">      collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 移除注释</span></span><br><span class="line">      removeComments: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>压缩js，首先将模式变为生产模式，接着：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">      <span class="comment">// 预设</span></span><br><span class="line">    presets: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 按需加载</span></span><br><span class="line">          useBuiltIns: <span class="string">'usage'</span>,</span><br><span class="line">          <span class="comment">// 指定core-js的版本</span></span><br><span class="line">          corejs: &#123;</span><br><span class="line">              version: <span class="number">3</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 指定兼容性做到哪个版本的浏览器</span></span><br><span class="line">          targets: &#123;</span><br><span class="line">              chrome: <span class="string">'60'</span>,</span><br><span class="line">              firefox: <span class="string">'60'</span>,</span><br><span class="line">              ie: <span class="string">'9'</span>,</span><br><span class="line">              edge: <span class="string">'16'</span>,</span><br><span class="line">              safari: <span class="string">'12'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HMR：局部热部署"><a href="#HMR：局部热部署" class="headerlink" title="HMR：局部热部署"></a>HMR：局部热部署</h4><p>就是修改css样式代码或者js代码，就只加载局部修改的，不会全部加载，可以优化性能，提升速度。<br>首先需要开启热部署在devServer中添加代码： hot: true // 支持局部热更新  。</p><ul><li>样式文件： 支持使用HMR功能， 必须是style-loader(内部实现了HMR)</li><li>HTML文件：不支持使用HMR功能（不需要）但能实现-》修改入口：    entry: [‘./src/js/index.js’, ‘./src/index.html’],</li><li>js文件 -》修改js代码（但HMR只能处理非入口文件，）：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="comment">// module.hot 为true，开启了HMR功能</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./router.js'</span>, () =&gt; &#123;</span><br><span class="line">    logRouter();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h4><p>生成源代码到构建后代码的映射， 映射–&gt; 精准定位错误（如果写错了，可以找到对应的错误的地方）<br>在这个module.exports={<br>devtool: ‘cheap-source-map’//取值很多，source-map/cheap-source-map/inline-source-map等。<br>}</p><h4 id="oneOf"><a href="#oneOf" class="headerlink" title="oneOf"></a>oneOf</h4><ul><li>默认情况： 所有文件进入rules都会完整走一遍规则， 没有必要</li><li>oneOf : 只会匹配一个， 其它不会匹配<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">    enforce: <span class="string">'pre'</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">// fix: true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    oneOf: [</span><br><span class="line">      <span class="comment">// 1. 样式相关</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [...commonCssLoader]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [...commonCssLoader, <span class="string">'less-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><p>如上只会走oneof[]中的</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li><p>开启Babel缓存：cacheDirectory: true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">    presets: [</span><br><span class="line">      [</span><br><span class="line">        <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          useBuiltIns: <span class="string">'usage'</span>,</span><br><span class="line">          corejs: &#123;</span><br><span class="line">            version: <span class="number">3</span></span><br><span class="line">          &#125;,</span><br><span class="line">          targets: &#123;</span><br><span class="line">            chrome: <span class="string">'60'</span>,</span><br><span class="line">            firefox: <span class="string">'60'</span>,</span><br><span class="line">            ie: <span class="string">'9'</span>,</span><br><span class="line">            edge: <span class="string">'16'</span>,</span><br><span class="line">            safari: <span class="string">'12'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    ],</span><br><span class="line">      cacheDirectory: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>开启文件资源缓存<br>改变文件名称<br>contenthash 【对文件内容级别的】-》chunkhash （<strong>那个变了 改那个</strong>）—》hash（<strong>每次每个构建打包都在变</strong>）【工程级别】，就像如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'js/dist.[contenthash:10].js'</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">  filename: <span class="string">'css/index.[contenthash:10].css'</span>,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure></li></ul><p>等等，改变构建后的文件名称。</p><h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><p>分割自有模块和三方模块</p><ul><li><p>分割三方的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分割自有的：在入口文件中配置（入口：index.js,其他：other.js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'other' */</span><span class="string">"./other.js"</span>).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文件加载成功！"</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文件加载失败！"</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>多入口一般会多输出，比如有两个入口文件，index,js,other.js，如果想让构建出的名字与构建前一样，在入口文件处应该这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><p>如果想让不一样:filename: ‘js/dist.js’,//dist自定义</p><h4 id="懒加载和预加载"><a href="#懒加载和预加载" class="headerlink" title="懒加载和预加载"></a>懒加载和预加载</h4><p>懒加载：默认加载的时候是从上往下加载，这样可能在文件特别大的时候会加载的特别慢，懒加载就是分流分掉了，只加载用到的，用不到的不加载或者在用的时候再去加载。<br>预加载：优先加载要用到的，</p><h4 id="webpack、grunt、glup的区别："><a href="#webpack、grunt、glup的区别：" class="headerlink" title="webpack、grunt、glup的区别："></a>webpack、grunt、glup的区别：</h4><p>webpack基于模块化打包的工具，有一个入口，最后打包生成一个出口，而后两者基于任务运行的工具，这个任务可以是webpack中环节的一部分。</p><h4 id="loader和plugin的区别"><a href="#loader和plugin的区别" class="headerlink" title="loader和plugin的区别"></a>loader和plugin的区别</h4><p>plugin是插件，它是扩展webpack的功能，让webpack更具有灵活性和可操作性，<br>loader是加载器：对项目中的模块进行解析，就像css-loader只能解析css模块的东西。</p><h4 id="bundle-chunk-module"><a href="#bundle-chunk-module" class="headerlink" title="bundle,chunk,module"></a>bundle,chunk,module</h4><p>bundle:打包出来的文件<br>chunk：代码块，一个chunk由多个模块组成，用于代码的合并和分割。<br>module：模块，一个模块对应一个文件，webpack会在entry中递归找出所有模块。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么要使用webpack&quot;&gt;&lt;a href=&quot;#为什么要使用webpack&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用webpack&quot;&gt;&lt;/a&gt;为什么要使用webpack&lt;/h4&gt;&lt;p&gt;因为在前端开发中，为了遵循模块化开发，会产生很多互相依赖的单独文件，在加载的时候会发送很多请求，导致加载速度慢，再比如一些像less或者es6的一些东西浏览器根本识别不了，这时就需要手动转为css,但是太麻烦了。为了解决诸多的问题就使用webpack,将这个js模块，css模块，img模块统统构建出压缩合并的产品。&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://bzkco70.cn/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>MVVM详解</title>
    <link href="http://bzkco70.cn/2020/12/19/MVVM/"/>
    <id>http://bzkco70.cn/2020/12/19/MVVM/</id>
    <published>2020-12-18T16:00:00.000Z</published>
    <updated>2020-12-19T02:06:22.400Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../../../assets/blogImg/MVVM.png" alt="MVVM"></p><a id="more"></a><p>ViewModel 层，它就像是一个中转站，负责转换 Model 中的数据对象，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。<br>View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;../../../../../assets/blogImg/MVVM.png&quot; alt=&quot;MVVM&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MVVM" scheme="http://bzkco70.cn/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>CSRF和XSRF</title>
    <link href="http://bzkco70.cn/2020/12/19/CSRF%E5%92%8CXSRF%E6%94%BB%E5%87%BB/"/>
    <id>http://bzkco70.cn/2020/12/19/CSRF和XSRF攻击/</id>
    <published>2020-12-18T16:00:00.000Z</published>
    <updated>2020-12-21T11:34:37.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h4><p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。</p><a id="more"></a><p><img src="../../../../../assets/blogImg/CSRF.png" alt="CSRF"></p><h4 id="XXS攻击"><a href="#XXS攻击" class="headerlink" title="XXS攻击"></a>XXS攻击</h4><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。<br>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。<br><img src="../../../../../assets/blogImg/xxs.png" alt="XXS"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;CSRF攻击&quot;&gt;&lt;a href=&quot;#CSRF攻击&quot; class=&quot;headerlink&quot; title=&quot;CSRF攻击&quot;&gt;&lt;/a&gt;CSRF攻击&lt;/h4&gt;&lt;p&gt;CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSRF、XSRF" scheme="http://bzkco70.cn/tags/CSRF%E3%80%81XSRF/"/>
    
  </entry>
  
  <entry>
    <title>ajax、fetch、axios详解</title>
    <link href="http://bzkco70.cn/2020/12/18/%E4%B8%89%E5%A4%A7%E8%AF%B7%E6%B1%82%E6%80%BB%E7%BB%93/"/>
    <id>http://bzkco70.cn/2020/12/18/三大请求总结/</id>
    <published>2020-12-17T16:00:00.000Z</published>
    <updated>2020-12-21T11:54:50.217Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p>  ajax 是对原生XHR的封装。重点就是首先实例一个XMLHttpRequest对象，用其中的open（在open方法中的true为异步，如果为false就是同步）方法建立连接；send方法传输数据（前端传到后台）；然后再利用onreadystatechange 监听readyState的变化，它本身针对MVC编程（最典型的MVC就是jsp+servlet+javabean模式）</p><a id="more"></a><ul><li><p>I.get:没有参数可以不用在url后面拼接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="comment">// 1. 获取用户输入的内容</span></span><br><span class="line">  <span class="keyword">var</span> account = <span class="built_in">document</span>.getElementById(<span class="string">'account'</span>).value;</span><br><span class="line">  <span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">'pwd'</span>).value;</span><br><span class="line">  xhr.open(<span class="string">'get'</span>, <span class="string">'http://localhost:3000/api/two?account='</span> + account + <span class="string">'&amp;pwd='</span> + pwd + <span class="string">'&amp;random='</span> + getRandomStr(), <span class="literal">true</span>);</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>II.post:没有参数在send中也不必写参数，请求头设不设置看需求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev1</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 获取用户输入的内容</span></span><br><span class="line">  <span class="keyword">var</span> account = <span class="built_in">document</span>.getElementById(<span class="string">'account'</span>).value;</span><br><span class="line">  <span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">'pwd'</span>).value;</span><br><span class="line">  <span class="comment">// 2. 创建网络请求对象</span></span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">'post'</span>, <span class="string">'http://localhost:3000/api/five'</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 设置请求头</span></span><br><span class="line">  xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">  xhr.send(<span class="string">'name=zs&amp;age=19'</span>);</span><br><span class="line">  xhr.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'请求失败！'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>III.优缺点</p></li><li><p>优点(（这个整个页面刷新和局部页面刷新，整个页面刷新就是整个页面重新加载，局部刷新就是整个页面当中的一小块刷新）)</p><ul><li>AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。</li><li>AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。</li><li>减轻服务器的负担,按需取数据,最大程度的减少冗余请求。</li><li>基于xml标准化,并被广泛支持,不需安装插件等，进一步促进页面和数据的分离。</li><li>局部刷新页面,减少用户心理和实际的等待时间,带来更好的用户体验。</li></ul></li><li><p>缺点</p><ul><li>AJAX干掉了Back和History功能，即对浏览器机制的破坏。</li><li>在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记忆历史记录中的静态页面。一个被完整读入的页面与一个已经被动态修改过的页面之间的差别非常微妙；用户通常会希望单击后退按钮能够取消他们的前一次操作，但是在Ajax应用程序中，这将无法实现。 </li><li>安全问题技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。 </li><li>对搜索引擎的支持比较弱。如果使用不当，AJAX会增大网络数据的流量，从而降低整个系统的性能。</li><li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案。</li></ul></li></ul><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p>axios其实就是在ajax的基础上加了promise，符合现在的MVVM（<a href="https://www.bzkco70.cn/2020/12/18/MVVM/" target="_blank" rel="noopener">MVVM</a>）</p><ul><li><p> I.get(不带参数把params去掉)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'get'</span>,</span><br><span class="line">  url: <span class="string">'http://demo.itlike.com/web/xlmc/api/homeApi/categoriesdetail/lk001'</span>,</span><br><span class="line">  <span class="comment">// 参数传递</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>II.post</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'http://demo.itlike.com/web/xlmc/api/homeApi/categoriesdetail/lk001'</span>,</span><br><span class="line">  <span class="comment">// 参数传递-data</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'撩课学院'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>III.并发请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url: <span class="string">'http://demo.itlike.com/web/xlmc/api/homeApi/categoriesdetail/lk001'</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url: <span class="string">'http://demo.itlike.com/web/xlmc/api/homeApi/categoriesdetail/lk002'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>axios.all返回的结果是一个数组，可以使用axios.spread将数组的值展开，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url: <span class="string">'http://demo.itlike.com/web/xlmc/api/homeApi/categoriesdetail/lk001'</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    url: <span class="string">'http://demo.itlike.com/web/xlmc/api/homeApi/categoriesdetail/lk002'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><ul><li>IV.优缺点<br>因为axios是<a href="https://baike.baidu.com/item/%E5%B0%A4%E9%9B%A8%E6%BA%AA/2281470" target="_blank" rel="noopener">尤雨溪</a>力推的，所以来看看优点吧（其主要原因是暂时也没发现什么缺点，如果有人发现缺点，请联系我的邮箱告知（<a href="mailto:&#x32;&#54;&#57;&#50;&#x38;&#49;&#x37;&#55;&#54;&#x32;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x32;&#54;&#57;&#50;&#x38;&#49;&#x37;&#55;&#54;&#x32;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109;</a>）,谢谢）</li><li>从浏览器中创建 XMLHttpRequest </li><li>从 node.js 发出 http 请求 </li><li>支持 Promise API </li><li>拦截请求和响应 </li><li>提供了一些并发请求的接口（重要，方便了很多的操作）。</li><li>转换请求和响应数据。</li><li>取消请求。</li><li>自动转换 JSON 数据。</li><li>客户端支持防止<a href="https://www.bzkco70.cn/2020/12/18/CSRF%E5%92%8CXSRF%E6%94%BB%E5%87%BB/" target="_blank" rel="noopener">CSRF、XSRF</a>。</li></ul><h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><ul><li><p>I.get</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> Request(URL, &#123; <span class="attr">method</span>: <span class="string">'GET'</span>, <span class="attr">cache</span>: <span class="string">'reload'</span> &#125;);</span><br><span class="line">fetch(req).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">  insertPhotos(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>II.post</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于req对象创建新的postReq对象</span></span><br><span class="line"><span class="keyword">var</span> postReq = <span class="keyword">new</span> Request(req, &#123; <span class="attr">method</span>: <span class="string">'POST'</span> &#125;);</span><br><span class="line">fetch(req).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> response.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123;</span><br><span class="line">  insertPhotos(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>III.优缺点</p></li><li><p>优点</p><ul><li>更加底层，提供的API丰富（request, response）</li><li>脱离了XHR，是ES规范里新的实现方式</li><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li><li>同构(为什么同构：目前，Fetch API在各个浏览器上的实现方式不一致。该模块将使您能够fetch以跨浏览器兼容的方式在Node代码中使用)方便，使用 <a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="noopener">isomorphic-fetch</a>，代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'isomorphic-fetch'</span>);</span><br><span class="line">fetch(<span class="string">'//offline-news-api.herokuapp.com/stories'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (response.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Bad response from server"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">stories</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(stories);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>缺点</p><ul><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以.</li><li>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Ajax&quot;&gt;&lt;a href=&quot;#Ajax&quot; class=&quot;headerlink&quot; title=&quot;Ajax&quot;&gt;&lt;/a&gt;Ajax&lt;/h4&gt;&lt;p&gt;  ajax 是对原生XHR的封装。重点就是首先实例一个XMLHttpRequest对象，用其中的open（在open方法中的true为异步，如果为false就是同步）方法建立连接；send方法传输数据（前端传到后台）；然后再利用onreadystatechange 监听readyState的变化，它本身针对MVC编程（最典型的MVC就是jsp+servlet+javabean模式）&lt;/p&gt;
    
    </summary>
    
    
      <category term="ajax、fetch、axios" scheme="http://bzkco70.cn/tags/ajax%E3%80%81fetch%E3%80%81axios/"/>
    
  </entry>
  
  <entry>
    <title>cross-origin(跨域)详解</title>
    <link href="http://bzkco70.cn/2020/12/16/cross-origin/"/>
    <id>http://bzkco70.cn/2020/12/16/cross-origin/</id>
    <published>2020-12-15T16:00:00.000Z</published>
    <updated>2020-12-21T11:48:46.990Z</updated>
    
    <content type="html"><![CDATA[<!-- ![这是一个老头](../../../../../assets/blogImg/bys0.jpg) --><h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>就是非同源请求，同源即端口号、主机和协议相同。</p><a id="more"></a><h4 id="为什么会出现"><a href="#为什么会出现" class="headerlink" title="为什么会出现"></a>为什么会出现</h4><p>由于浏览器的同源策略限制，</p><ol><li>通常浏览器允许进行跨域的写操作，如链接、重定向</li><li>通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签    </li><li>通常浏览器不允许跨域读操作（Cross-origin reads）</li></ol><h4 id="jsonP解决跨域"><a href="#jsonP解决跨域" class="headerlink" title="jsonP解决跨域"></a>jsonP解决跨域</h4><ul><li><p>客户端：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/localhost:3000/</span>?callback=getData<span class="string">"&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>服务器端</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`收到客户端请求了: <span class="subst">$&#123;req.url&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">var</span> _callback=req.query.callback;<span class="comment">//接收到的是一个函数</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      status_code: <span class="number">200</span>,</span><br><span class="line">      result: &#123;</span><br><span class="line">        name: <span class="string">'张三'</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        friends: [<span class="string">'李四'</span>, <span class="string">'王五'</span>, <span class="string">'赵六'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(_callback+<span class="string">"("</span>+data+<span class="string">")"</span>);<span class="comment">//相当于响应的是getData(data)的执行结果。</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原理：由于同源策略限制，虽然不能通过XMLhttprequest,但能引入js文件，随后触发回调，服务器将数据返回给客户端。</span><br><span class="line">优点：兼容性好，可以解决不同浏览器的跨域问题。</span><br><span class="line">缺点：只支持<span class="keyword">get</span>请求，不安全，</span><br></pre></td></tr></table></figure><h4 id="req-query、req-params、req-body的区别"><a href="#req-query、req-params、req-body的区别" class="headerlink" title="req.query、req.params、req.body的区别"></a>req.query、req.params、req.body的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>req.params:</span><br><span class="line">  所对应的url长这个样子 http:<span class="comment">//localhost:3000/10</span></span><br><span class="line">  app.get(<span class="string">"/:id"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req.res</span>)</span>&#123;</span><br><span class="line">    res.send(req.params[<span class="string">"id"</span>]);</span><br><span class="line">  &#125;)</span><br><span class="line">  通过这样才能拿到id的值，即<span class="number">10</span>；</span><br><span class="line"><span class="number">2.</span>req.query:</span><br><span class="line">  所对应的url长这个样子http:<span class="comment">//localhost:3000/?id=10</span></span><br><span class="line">  app.get(<span class="string">"/"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">      res.send(req.query[<span class="string">"id"</span>]);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="number">3.</span>req.body:</span><br><span class="line">  这个用在post请求中。通常用法：</span><br><span class="line">  app.post(<span class="string">"/login"</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    req.body.pwd;</span><br><span class="line">    req.body.name;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="CORS：跨域资源共享"><a href="#CORS：跨域资源共享" class="headerlink" title="CORS：跨域资源共享"></a>CORS：跨域资源共享</h4><p>  主要分为简单请求和非简单请求，平时差不多用到的就是get post，所以简单请求就够了，浏览器会自动在请求头中添加 origin 字段，我们不需要操作：origin ：<a href="http://localhost:3000。在服务器端：配置Access-Control-Allow-Origin属性。指定允许的请求源域名，可以通过指定为" target="_blank" rel="noopener">http://localhost:3000。在服务器端：配置Access-Control-Allow-Origin属性。指定允许的请求源域名，可以通过指定为</a> *来指定所有域名。配置该属性的方式为：在app.js中添加如下代码：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//  res.header("Access-Control-Allow-Origin", "http://localhost:3000");</span></span><br><span class="line">    res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);<span class="comment">//*就是所有域名都能跨域</span></span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="string">'/'</span>, index);</span><br></pre></td></tr></table></figure></p><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。<br>postMessage(data,origin)方法接受两个参数：<br>// 注意这里不是要获取iframe的dom引用，而是iframe window的引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://10.73.154.73:8088'</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'data from domain2 sss ---&gt; '</span> + e.data);</span><br><span class="line">  &#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h4 id="vue常用的跨域方法"><a href="#vue常用的跨域方法" class="headerlink" title="vue常用的跨域方法"></a>vue常用的跨域方法</h4><p>在根目录下创建vue.config.js文件,内容参考如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">'/'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://demo.itlike.com/web/xlmc'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">//上面的pathRewrite就是遇到第二哥/api的时候替换为空，</span></span><br><span class="line">      <span class="string">'/pay'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://47.98.157.152/WXPayProject/pay'</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/pay'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="react常用跨域方法"><a href="#react常用跨域方法" class="headerlink" title="react常用跨域方法"></a>react常用跨域方法</h4><p>在src目录下创建setupProxy.js,内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(</span><br><span class="line">    <span class="string">'/api'</span>,</span><br><span class="line">    createProxyMiddleware(&#123;</span><br><span class="line">      target: <span class="string">'http://localhost:3001'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- ![这是一个老头](../../../../../assets/blogImg/bys0.jpg) --&gt;

&lt;h4 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h4&gt;&lt;p&gt;就是非同源请求，同源即端口号、主机和协议相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="跨域" scheme="http://bzkco70.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>promise详解</title>
    <link href="http://bzkco70.cn/2020/12/16/promise/"/>
    <id>http://bzkco70.cn/2020/12/16/promise/</id>
    <published>2020-12-15T16:00:00.000Z</published>
    <updated>2020-12-21T11:49:37.010Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>)</span><br><span class="line">fs.readFile(__dirname + <span class="string">'/data/a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(__dirname + <span class="string">'/data/b.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面这些代码输出是无序的，虽然是异步的但仍然无法确定哪个先输出，所以接着就有了如下的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(__dirname + <span class="string">'/data/a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  fs.readFile(__dirname + <span class="string">'/data/b.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    fs.readFile(__dirname + <span class="string">'/data/c.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为了让其有顺序的输出：就第一个请求输出有结果再去第二个请求，以此类推，就会形成著名的回调地狱，为了解决这类问题promise出现了。</p><h4 id="prominse"><a href="#prominse" class="headerlink" title="prominse"></a>prominse</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(请求<span class="number">1</span>)</span><br><span class="line">  .then(请求<span class="number">2</span>(请求结果<span class="number">1</span>))</span><br><span class="line">  .then(请求<span class="number">3</span>(请求结果<span class="number">2</span>))</span><br><span class="line">  .catch(处理异常(异常信息))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(__dirname + <span class="string">'/data/a.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log(data.toString());</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    resolve(data);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//如果resolve就会走then,如果reject就会走catch</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  <span class="comment">// 第二个promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(__dirname + <span class="string">'/data/bb.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  <span class="comment">// 第三个promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(__dirname + <span class="string">'/data/c.txt'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>promise一旦创建，立即执行</p><h4 id="promise封装"><a href="#promise封装" class="headerlink" title="promise封装"></a>promise封装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> readFile = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(...args, (err, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">readFile(path.join(__dirname, <span class="string">'data/a.txt'</span>)).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  <span class="keyword">return</span> readFile(path.join(__dirname, <span class="string">'data/b.txt'</span>));</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'我成功了！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'我财务自由了！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">'我真的一无所有！'</span>);</span><br><span class="line">result就是所有的promise都有结果才会输出(不论resolve或者reject，只要有结果)，只要有一个promise状态为reject则输出这个失败状态的promise返回的结果,在resolve的情况下且是按照顺序执行的，即使p3比p1先执行完，但在调用promise.all方法时，还是先输出p1, 再p3。</span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p3, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race"></a>promise.race</h4><p>Promise.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态（在抢票这样的场景中可能会遇到）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'我成功了！'</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">'我失败了！'</span>);</span><br><span class="line">  &#125;, <span class="number">50</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p2, p1]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="async-await-非常重要了"><a href="#async-await-非常重要了" class="headerlink" title="async/await(非常重要了)"></a>async/await(非常重要了)</h4><ul><li><p>async 用于声明异步函数，只要一个函数前面写了这个东西，那么它就是异步函数，await只能在前面加了async的函数里面使用，不能单独使用，者相辅相成。</p></li><li><p>async 返回的是一个Promise对象（就是在函数前面加了async，返回的就是一个promise，例如：async function itLike() {return ‘撩课学院’;console.log(itLike());），// Promise{‘撩课学院’}                             </p></li><li><p>await 后面跟一个promise对象，且必须是promise，但不必写then。</p></li><li><p>二者的使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">itLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await有点异步转同步的意思，就是等它执行完，后面才能执行</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">'后面的，等着'</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'------'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开发中的应用场景：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> request = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(time);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>1.promise写法：<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">request(<span class="number">200</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第一次结果: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> request(result + <span class="number">200</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第二次结果: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> request(result + <span class="number">200</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`第三次结果: <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2.async/await写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">itLike</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res1 = <span class="keyword">await</span> request(<span class="number">200</span>);</span><br><span class="line">  <span class="keyword">let</span> res2 = <span class="keyword">await</span> request(res1 + <span class="number">200</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> request(res2 + <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line">itLike().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;fs&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fs.readFile(__dirname + &lt;span class=&quot;string&quot;&gt;&#39;/data/a.txt&#39;&lt;/span&gt;, (err, data) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fs.readFile(__dirname + &lt;span class=&quot;string&quot;&gt;&#39;/data/b.txt&#39;&lt;/span&gt;, (err, data) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(data.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="promise" scheme="http://bzkco70.cn/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>git详解</title>
    <link href="http://bzkco70.cn/2020/12/11/git/"/>
    <id>http://bzkco70.cn/2020/12/11/git/</id>
    <published>2020-12-10T16:00:00.000Z</published>
    <updated>2020-12-21T11:49:01.598Z</updated>
    
    <content type="html"><![CDATA[<h4 id="git的功能"><a href="#git的功能" class="headerlink" title="git的功能"></a>git的功能</h4><p>代码回滚、代码合并、版本备份、权限控制、追究责任等。<br>他能追踪一个项目从诞生到定案的过程、记录项目所有变化，无限制返回、查看特定版本的修情况。</p><a id="more"></a><h4 id="git和svn比较"><a href="#git和svn比较" class="headerlink" title="git和svn比较"></a>git和svn比较</h4><p>git为分布式版本控制（在每个客户端都有一份完整的代码仓库, 可以在每个客户端自行管理）<br>svn为集中式版本控制（所有的代码都集中在一块, 统一进行管理）</p><h4 id="git的工作流程"><a href="#git的工作流程" class="headerlink" title="git的工作流程"></a>git的工作流程</h4><p>git add .(.或者其他文件) -&gt; git commit -m “” -&gt; git pull -&gt;git push  </p><h4 id="git的使用经验"><a href="#git的使用经验" class="headerlink" title="git的使用经验"></a>git的使用经验</h4><p>每天走之前, 提交一份没有问题的代码到服务器，每天早上来之前, 从服务器拉一份最新的代码到本地再进行开发  </p><h4 id="git的使用方式"><a href="#git的使用方式" class="headerlink" title="git的使用方式"></a>git的使用方式</h4><p>命令行、ws这些前端工具。</p><h4 id="常见的unix命令"><a href="#常见的unix命令" class="headerlink" title="常见的unix命令"></a>常见的unix命令</h4><ul><li>必学命令<br>  help [子命令] : 查看某一个具体的子命令的使用方法  </li><li>常用命令  <ul><li>cd path : 将当前路径切换到path路径<ul><li>pwd ：查看当前所在路径</li><li>ls (-a / -l / -G) :  查看当前文件夹下所有文件及文件夹</li><li>touch filename1 filename2 ： 创建一个或者多个文件 </li><li>rm filename : 删除文件</li><li>cat filename ：查看文件内容</li><li>less filename ：分页查看文件内容</li><li>mkdir 文件夹名称 ：创建一个文件夹</li><li>rmdir 文件夹名称 ：删除一个文件夹</li><li>mv oldFilePath newFilePath ：移动文件(可借助此命令给文件重命名)  </li></ul></li></ul></li><li>vi编辑器<br>三种模式：命令行模式、末行模式、输入模式，输入vi就进入命令行模式，输入a或i就到插入模式，接着esc到命令行模式，接着shift+:到末行模式，wq保存并退出，！q强制退出。末行模式esc到命令行模式。  </li></ul><h4 id="git工作原理："><a href="#git工作原理：" class="headerlink" title="git工作原理："></a>git工作原理：</h4><p>git有工作区和版本控制库这两个东西，工作区就是文件目录下（除了.git）的就是工作区，版本库就是目录下.git目录，当添加/修改/删除后，git add后先是将添加的文件推送到版本库的暂缓区，git commit 后将添加的文件推送到版本库的分支上，默认是master分支，通过HEAD指针来切换分支。  </p><h4 id="git本地仓库的搭建："><a href="#git本地仓库的搭建：" class="headerlink" title="git本地仓库的搭建："></a>git本地仓库的搭建：</h4><p>初始化git init-&gt;配置仓库（告诉git你是谁，怎么联系。。。git config user.name “你的名字”  git…email “”,配置好了查看这些配置的信息，git config -l）。</p><h4 id="git-基本使用："><a href="#git-基本使用：" class="headerlink" title="git 基本使用："></a>git 基本使用：</h4><p>创建文件并提交：touch 文件 git add  git commit-》修改文件并提交-》删除文件并提交：git rm 文件 。。。<br>git 日志查看的方式：1）git log  2)git relog  版本号唯一<br>git 查看文件状态：git status  红色表示文件添加或修改或删除的文件没有被添加到暂缓区，绿色表示文件在暂缓去等待提交。</p><h4 id="git版本回退："><a href="#git版本回退：" class="headerlink" title="git版本回退："></a>git版本回退：</h4><p>如果尚未提交：回退到当前版本：git reset –hard HEAD<br>如果提交了：<br>git reset –hard HEAD^ 重置到上个版本<br>git reset –hard HEAD~2 重置到往上2个版本<br>git reset –hard  HEAD@{版本号}七位版本号 重置到指定版本<br>然后再使用git push –force将本次变更强行推送至服务器。这样在服务器上的对应版本的错误提交也彻底消失了。</p><h4 id="共享库分类："><a href="#共享库分类：" class="headerlink" title="共享库分类："></a>共享库分类：</h4><p>远程共享库和本地共享库，远程的就比如GitHub，本地共享库的例子好比如在一个电脑上，有一个共享库，另外有两个文件目录分别在本地共享库拉取提交代码。git clone “c:/user….(本地共享库地址)”，搭建本地共享库mkdir share/cd share/git init –bare。</p><h4 id="解决冲突："><a href="#解决冲突：" class="headerlink" title="解决冲突："></a>解决冲突：</h4><p>这个通常我们在使用前最好拉一下代码，否则如果本地文件的版本低于共享库的文件版本, 提交时就会报超时错误，冲突解决：如果俩人在用一个共享库的一个文件，另一个修改提交并且推送，另一个也修改提交推送时就会提升merge，这时就要合并一下代码接着点击merge，这时通常把别人的放在前面，自己的放在后面，接着apply一下，如果没有成功重新推送一下。</p><h4 id="配置忽略文件："><a href="#配置忽略文件：" class="headerlink" title="配置忽略文件："></a>配置忽略文件：</h4><p>有些文件对自己有用，对别人没有，就不必上传到服务器了。<br>  就是在当前目录下，touch .gitignore  接着打开这个文件在里面写上要忽略的文件名即可。只能忽略工作区文件，如果已经在暂缓区，则无法忽略。</p><h4 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h4><p>  首先如果远程有多个分支，如果是master分支，直接拉，如果是有其他分支，拉取代码命令为：git clone -b dev ssh地址<br>查看当前分支  git branch -a  -&gt;查看本地分支git branch -&gt;创建分支 git branch 分支名称 -&gt;将创建的分支推送都远程git push origin 分支名称 -&gt;切换分支 git checkout 分支名称 -&gt;删除分支 git branch -d 分支名称 -&gt;删除远程分支 git push origin :分支名称。<br>这里如果想将其他分支合并到master分支，首先提交当前分支的代码，接着切换到master分支，master分支如果是多人开发就要pull一下，接着就是合并 git merge dev(假设要合并dev分支的) 接着就git status 查看合并代码是否有冲突，最后git push origin master,如果想切回原来的分支继续开发就git checkout dev </p><h4 id="git打包"><a href="#git打包" class="headerlink" title="git打包"></a>git打包</h4><p>  给项目打一个标签，就是打一个版本，git tag -a v1.0 -m “tag”,接着上传 git push origin v1.0</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;git的功能&quot;&gt;&lt;a href=&quot;#git的功能&quot; class=&quot;headerlink&quot; title=&quot;git的功能&quot;&gt;&lt;/a&gt;git的功能&lt;/h4&gt;&lt;p&gt;代码回滚、代码合并、版本备份、权限控制、追究责任等。&lt;br&gt;他能追踪一个项目从诞生到定案的过程、记录项目所有变化，无限制返回、查看特定版本的修情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://bzkco70.cn/tags/git/"/>
    
  </entry>
  
</feed>
