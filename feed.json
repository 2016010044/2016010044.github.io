{"title":"CoolBreeze的博客","description":"web前端攻城狮","language":"en","link":"http://bzkco70.cn","pubDate":"Tue, 15 Dec 2020 16:00:00 GMT","lastBuildDate":"Wed, 16 Dec 2020 08:16:54 GMT","generator":"hexo-generator-json-feed","webMaster":"CoolBreeze","items":[{"title":"cross-origin(跨域)详解","link":"http://bzkco70.cn/2020/12/16/cross-origin/","description":"1.什么是跨域就是非同源请求，同源即端口号、主机和协议相同。","pubDate":"Tue, 15 Dec 2020 16:00:00 GMT","guid":"http://bzkco70.cn/2020/12/16/cross-origin/","category":"跨域"},{"title":"promise详解","link":"http://bzkco70.cn/2020/12/16/promise/","description":"背景12345678const fs = require(\"fs\")fs.readFile(__dirname + '/data/a.txt', (err, data) =&gt; &#123; console.log(data.toString());&#125;);fs.readFile(__dirname + '/data/b.txt', (err, data) =&gt; &#123; console.log(data.toString());&#125;); 上面这些代码输出是无序的，虽然是异步的但仍然无法确定哪个先输出，所以接着就有了如下的写法：123456789fs.readFile(__dirname + '/data/a.txt', (err, data) =&gt; &#123; console.log(data.toString()); fs.readFile(__dirname + '/data/b.txt', (err, data) =&gt; &#123; console.log(data.toString()); fs.readFile(__dirname + '/data/c.txt', (err, data) =&gt; &#123; console.log(data.toString()); &#125;); &#125;);&#125;); 为了让其有顺序的输出：就第一个请求输出有结果再去第二个请求，以此类推，就会形成著名的回调地狱，为了解决这类问题promise出现了。123456789101112131415161718192021222324252627282930313233343536373839404142## prominsenew Promise(请求1) .then(请求2(请求结果1)) .then(请求3(请求结果2)) .catch(处理异常(异常信息))new Promise((resolve, reject) =&gt; &#123; fs.readFile(__dirname + '/data/a.txt', (err, data) =&gt; &#123; // console.log(data.toString()); if (err) &#123; reject(err); &#125; resolve(data); &#125;); //如果resolve就会走then,如果reject就会走catch&#125;).then((data) =&gt; &#123; console.log(data.toString()); // 第二个promise return new Promise((resolve, reject) =&gt; &#123; fs.readFile(__dirname + '/data/bb.txt', (err, data) =&gt; &#123; if (err) &#123; reject(err); &#125; resolve(data); &#125;); &#125;)&#125;).then((data) =&gt; &#123; console.log(data.toString()); // 第三个promise return new Promise((resolve, reject) =&gt; &#123; fs.readFile(__dirname + '/data/c.txt', (err, data) =&gt; &#123; if (err) &#123; reject(err); &#125; resolve(data); &#125;); &#125;)&#125;).then((data) =&gt; &#123; console.log(data.toString());&#125;).catch((err) =&gt; &#123; console.log(err);&#125;); promise一旦创建，立即执行 promise封装12345678910111213141516let readFile = (...args) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(...args, (err, data) =&gt; &#123; if (err) &#123; reject(err); &#125; resolve(data); &#125;); &#125;)&#125;;readFile(path.join(__dirname, 'data/a.txt')).then((data) =&gt; &#123; console.log(data.toString()); return readFile(path.join(__dirname, 'data/b.txt'));&#125;).then((data) =&gt; &#123; console.log(data.toString());&#125;); promise.all12345678910111213let p1 = new Promise((resolve, reject) =&gt; &#123; resolve('我成功了！');&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; resolve('我财务自由了！');&#125;);let p3 = Promise.reject('我真的一无所有！');result就是所有的promise都有结果才会输出(不论resolve或者reject，只要有结果)，只要有一个promise状态为reject则输出这个失败状态的promise返回的结果,在resolve的情况下且是按照顺序执行的，即使p3比p1先执行完，但在调用promise.all方法时，还是先输出p1, 再p3。Promise.all([p1, p3, p2]).then((result) =&gt; &#123; console.log(result);&#125;).catch((error) =&gt; &#123; console.log(error);&#125;); promise.racePromise.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态（在抢票这样的场景中可能会遇到）1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('我成功了！'); &#125;, 100);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('我失败了！'); &#125;, 50);&#125;);Promise.race([p2, p1]).then((result) =&gt; &#123; console.log(result);&#125;).catch((error) =&gt; &#123; console.log(error);&#125;); async/await(非常重要了) async 用于声明异步函数，只要一个函数前面写了这个东西，那么它就是异步函数，await只能在前面加了async的函数里面使用，不能单独使用，二者相辅相成。 async 返回的是一个Promise对象（就是在函数前面加了async，返回的就是一个promise，例如：async function itLike() { return ‘撩课学院’;}console.log(itLike());），// Promise{‘撩课学院’} await 后面跟一个promise对象，且必须是promise，但不必写then。 二者的使用： 12345678910async function itLike() &#123; // await有点异步转同步的意思，就是等它执行完，后面才能执行 let result = await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve('后面的，等着'); &#125;, 2000); &#125;); console.log(result); console.log('------');&#125; 开发中的应用场景： 1234567let request = (time) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(time); &#125;, time); &#125;)&#125;; promise写法： 1234567891011request(200).then((result) =&gt; &#123; console.log(`第一次结果: $&#123;result&#125;`); return request(result + 200);&#125;).then((result) =&gt; &#123; console.log(`第二次结果: $&#123;result&#125;`); return request(result + 200);&#125;).then((result) =&gt; &#123; console.log(`第三次结果: $&#123;result&#125;`);&#125;).catch(err =&gt; &#123; console.log();&#125;); async/await写法:12345678910async function itLike() &#123; let res1 = await request(200); let res2 = await request(res1 + 200); return await request(res2 + 200);&#125;itLike().then((res) =&gt; &#123; console.log(res);&#125;).catch((err) =&gt; &#123; console.log(err);&#125;);","pubDate":"Tue, 15 Dec 2020 16:00:00 GMT","guid":"http://bzkco70.cn/2020/12/16/promise/","category":"promise"},{"title":"git详解","link":"http://bzkco70.cn/2020/12/11/git/","description":"git的功能代码回滚、代码合并、版本备份、权限控制、追究责任等。他能追踪一个项目从诞生到定案的过程、记录项目所有变化，无限制返回、查看特定版本的修情况。","pubDate":"Thu, 10 Dec 2020 16:00:00 GMT","guid":"http://bzkco70.cn/2020/12/11/git/","category":"git"}]}